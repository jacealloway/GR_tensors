README:

Help on class calcTensor in module functions:

class calcTensor(builtins.object)
 |  ***Requires numpy as 'np' and sympy as 'sp' installation (import) to load.***
 |
 |  **Class:** Functions to compute tensor identities.
 |
 |  **Functions:**
 |      * coordinateGenerator
 |      * metricGenerator
 |      * deltaFunction
 |      * chrisUDD
 |      * riemannUDDD
 |      * ricciDD
 |      * ricciScalar
 |      * retrieveAll
 |      * classInfo
 |
 |  Methods defined here:
 |
 |  __init__(self)
 |      Initialize the class.
 |
 |  chrisUDD(g_upup: list[str], g_dndn: list[str], xup: list[str]) -> list[str]
 |      **Returns:** dtype = numpy.array. NxNxN dimensional array of symbolic Christoffel symbols of tensor type 'up-down-down' generated from upstairs and downstairs metric tensors.
 |
 |      *g_upup:* dtype = numpy.array. NxN upstairs metric tensor of symbolic sympy values.
 |
 |      *g_dndn:* dtype = numpy.array. NxN downstairs metric tensor of symbolic sympy values.
 |
 |      *xup:* dtype = numpy.array. Nx1 vector list of symbolic variables generated from sympy.symbols.
 |
 |  classInfo() -> <built-in function any>
 |      Retrieve class 'calcTensor' documentation.
 |
 |  coordinateGenerator(vars: list[str]) -> list[str]
 |      **Returns:** dtype = numpy.array. List of coordinate variables in N-vector contravariant tensor notation.
 |
 |      *vars:* List of symbolic strings generated by sympy.symbols.
 |
 |  deltaFunction(dimension: int) -> list[int]
 |      **Returns:** dtype = numpy.array. Kronecker Delta function of dimensionality N. Iterable through by tensor indices.
 |
 |      *dimension:* Input integer to specify dimension output array.
 |
 |  metricGenerator(vars: list[str]) -> tuple[list[str]]
 |      **Returns:** dtype = numpy.array. Metric tensor lower 'g_dndn' and upper 'g_upup' for symbolic calculation (tuple). Dimensionality out is equivalent to dimensionality in.
 |
 |      *vars:* Input array for 'g_dndn' metric of dimensionality NxN of symbolic strings generated by sympy.symbols.
 |
 |  retrieveAll(metric_vars: list[str], coordinates: list[str], return_type: str) -> None
 |      **Returns:** Any chosen value determine from previous functions.
 |
 |      *metric_vars:* numpy.array. Input array for 'g_dndn' metric of dimensionality NxN of symbolic strings generated by sympy.symbols.
 |
 |      *coordinates:* numpy.array. List of symbolic strings generated by sympy.symbols.
 |
 |      *return_type:* string. 'CC' for Christoffel symbols up-down-down. 'RMT' for Riemann tensor up-down-down-down. 'RIT' for Ricci tensor down-down. 'RS' for Ricci Scalar.
 |
 |  ricciDD(riemann: list[str]) -> list[str]
 |      **Returns:** dtype = numpy.array. NxN dimensional array of symbolic Ricci tensor of type 'down-down' generated from Riemann tensor.
 |
 |      *riemann:* dtype = numpy.array. NxNxNxN Riemann tensor of symbolic sympy values.
 |
 |  ricciScalar(ricciTensor: list[str], g_upup: list[str]) -> str
 |      **Returns:** dtype = string. Symbolic scalar value of type sympy variable. Contraction along two axes of Ricci tensor type 'down-down'.
 |
 |      *ricciTensor:* dtype = numpy array. NxN Ricci curvature tensor of symbolic sympy values.
 |
 |      *g_upup:* dtype = numpy array. NxN metric tensor of symbolic sympy values of type 'up-up' indexing.
 |
 |  riemannUDDD(christoffel: list[str], xup: list[str]) -> list[str]
 |      **Returns:** dtype = numpy.array. NxNxNxN dimensional array of symbolic Riemann tensor of type 'up-down-down-down' generated from Christoffel symbols.
 |
 |      *christoffel:* dtype = numpy.array. NxNxN Christoffel symbol tensor of symbolic sympy values.
 |
 |      *xup:* dtype = numpy.array. 1xN vector list of symbolic variables generated from sympy.symbols.
 |
 |  ----------------------------------------------------------------------
 |  Data descriptors defined here:
 |
 |  __dict__
 |      dictionary for instance variables
 |
 |  __weakref__
 |      list of weak references to the object
 |
 |
 |  ----------------------------------------------------------------------
 |  Example:
 |      import sympy as sp
 |      from functions import calcTensor as t
 |
 |      L, time, theta, phi = sp.symbols('L, time, theta, phi')
 |
 |      t.retrieveAll( [[L**2, 0, 0], 
 |                     [0, -(L**2)*(sp.cosh(time)**2),0], 
 |                     [0, 0, -(L**2)*(sp.sin(theta)**2)*(sp.cosh(time)**2)]],
 |                     [time, theta, phi], 'RIS')